// user_i2c.c
// Authors: Christian Auspland & Matthew Blanchard

#include <user_i2c.h>

// Static functions are not predefined to avoid flash issues
// void user_i2c_sda_set(bool stat);
// Desc: Sets the SDA line to the state (high or low)
// Args:
// 	bool state: The desired state for the SDA
// Returns: 
// 	Nothing
static void ICACHE_FLASH_ATTR user_i2c_sda_set(bool state)
{
	// To drive the line low, pull the pin low (low output)
	// To "drive" the line high, let it float at Hi-Z (input)
	if (state == 0) {
		gpio_output_set(0, SDA_BIT, SDA_BIT, 0);
	} else {
		gpio_output_set(SDA_BIT, 0, SDA_BIT, 0);
	}
	
	return;	
};

// void user_i2c_scl_set(bool state);
// Desc: Sets the SCL line to state (high or low);
// Args: 
// 	bool state: The desired state for the SCL
// Returns:
// 	Nothing
static void ICACHE_FLASH_ATTR user_i2c_scl_set(bool state)
{
	// To drive the line low, pull the pin low (low output)
	// To "drive" the line high, let it float at Hi-Z (input)
	if (state == 0) {
		gpio_output_set(0, SCL_BIT, SCL_BIT, 0);
	} else {
		gpio_output_set(SCL_BIT, 0, SCL_BIT, 0);
	}	

	return;
};



void ICACHE_FLASH_ATTR user_i2c_start_bit(void)
{
	// An I2C start bit begins with both SDA & SCL high.
	// It then pulls SDA low while keeping SCL high.
	user_i2c_sda_set(1);
	user_i2c_scl_set(1);
	os_delay_us(I2C_DELAY);
	user_i2c_sda_set(0);
	os_delay_us(I2C_DELAY);
	user_i2c_scl_set(0);

	return;
};

void ICACHE_FLASH_ATTR user_i2c_stop_bit(void)
{
	// An I2C stop bit starts with SDA low and SCL high.
	// It then pulls SDA high while keeping SCL high.
	os_delay_us(I2C_DELAY);
	user_i2c_scl_set(1);
	os_delay_us(I2C_DELAY);
	user_i2c_sda_set(1);
	os_delay_us(I2C_DELAY);

	return;
};

// bool user_i2c+scl_read(void);
// Desc: Reads the SCL line
// Args:
// 	None
// Returns:
// 	SCL line state
static vool ICACHE_FLASH_ATTR user_i2c_scl_read(void)
{
	// Read and return SCL line
	return GPIO_INPUT_GET(GPIO_ID_PIN(SCL_PIN));
};

uint8 ICACHE_FLASH_ATTR user_i2c_write_byte(uint8 byte)
{
	uint8 i = 0;	// Loop index
}







